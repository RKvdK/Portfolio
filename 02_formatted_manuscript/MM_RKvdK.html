<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The Doubly Robust Estimator</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="MM_RKvdK_files/libs/clipboard/clipboard.min.js"></script>
<script src="MM_RKvdK_files/libs/quarto-html/quarto.js"></script>
<script src="MM_RKvdK_files/libs/quarto-html/popper.min.js"></script>
<script src="MM_RKvdK_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="MM_RKvdK_files/libs/quarto-html/anchor.min.js"></script>
<link href="MM_RKvdK_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="MM_RKvdK_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="MM_RKvdK_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="MM_RKvdK_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="MM_RKvdK_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Doubly Robust Estimator</h1>
<p class="subtitle lead">MLARPIS 2026 Deliverable</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<section id="prologue" class="level3">
<h3 class="anchored" data-anchor-id="prologue">Prologue</h3>
<p>This document is a reproducible version of the research report that the author handed in for the research seminar course. The topic of the report is the application of the doubly robust estimator in statistical matching. One remark must be made. This report does not contain real results. This is still work in progress. However, the author included a figure to show what his intentions are regarding the presentation of the results. The data for this figure are completely made up, and not based on the described methodology.</p>
</section>
<section id="problem-statement" class="level3">
<h3 class="anchored" data-anchor-id="problem-statement">Problem Statement</h3>
<p>Both public and private organizations heavily rely on survey data, complemented with administrative and big data sources. However, in the past decades survey response rates have been declining <span class="citation" data-cites="luiten2020">(<a href="#ref-luiten2020" role="doc-biblioref">Luiten, Hox, and Leeuw 2020</a>)</span>. This introduces unit nonresponse, meaning that a sampled unit does not complete any part of the survey <span class="citation" data-cites="biemer2010">(<a href="#ref-biemer2010" role="doc-biblioref">Biemer 2010</a>)</span>. Within the total survey error (TSE) framework, this nonresponse potentially introduces bias and increased variance, also referred to as unit nonresponse error <span class="citation" data-cites="biemer2010 groves2010">(<a href="#ref-biemer2010" role="doc-biblioref">Biemer 2010</a>; <a href="#ref-groves2010" role="doc-biblioref">Groves and Lyberg 2010</a>)</span>. At the same time, society demands timelier statistics, for example regarding unexpected events or when the target variables are not jointly observed <span class="citation" data-cites="waal2015">(<a href="#ref-waal2015" role="doc-biblioref">Waal 2015</a>)</span>. To illustrate, consider a study of the relationship between educational attainment and smoking behavior. In practice, these variables may not be observed simultaneously. In this case, estimating the association between educational attainment and smoking behavior is not trivial. However, combining data sources based on common auxiliary variables would both increase the timeliness of the statistics, and address unit nonresponse by means of enhanced data efficiency use <span class="citation" data-cites="waal2015">(<a href="#ref-waal2015" role="doc-biblioref">Waal 2015</a>)</span>. Statistical matching provides a framework for combining data sources, for which promising results have been reported in survey applications <span class="citation" data-cites="donatiello2022">(<a href="#ref-donatiello2022" role="doc-biblioref">Donatiello et al. 2022</a>)</span>.</p>
</section>
<section id="statistical-matching" class="level3">
<h3 class="anchored" data-anchor-id="statistical-matching">Statistical Matching</h3>
<p>In statistical matching, a statistic is computed for variables that are observed in two or more separate datasets with no or small unit overlap <span class="citation" data-cites="dorazio2006">(<a href="#ref-dorazio2006" role="doc-biblioref">D’Orazio, Zio, and Scanu 2006</a>)</span>. In the classical statistical matching setting, two samples are considered. Each sample contains a different categorical target variable. Target variable Y is observed in sample A, while Z is observed in sample B. In both samples, a common auxiliary variable X is observed, whose levels refer to unique configurations of background characteristics. The goal is to estimate the true joint distribution of Y and Z. To do so, additional assumptions are required. A key assumption in statistical matching is the conditional independence assumption (CIA). The CIA states that the target variables are statistically independent given their common set of auxiliary variables <span class="citation" data-cites="dorazio2006">(<a href="#ref-dorazio2006" role="doc-biblioref">D’Orazio, Zio, and Scanu 2006</a>)</span>. Under the CIA, the association between Y and Z is fully explained by X, allowing the joint distribution to be estimated based on the marginal distributions that are observed in the separate samples. However, in practice, the CIA is often infeasible to test <span class="citation" data-cites="dorazio2006">(<a href="#ref-dorazio2006" role="doc-biblioref">D’Orazio, Zio, and Scanu 2006</a>)</span>. The auxiliary variables may not fully explain the association between the target variables, for example when there are unobserved confounders. Consequently, violation of the CIA can lead to biased estimates. To reduce reliance on CIA, statistical matching can be extended adopting an external sample in which both Y and a proxy variable (Y*) are observed. This proxy is an indirect but associated measure of target variable Y containing measurement errors. To illustrate this extension, consider the example concerning the relationship between educational attainment and smoking. Additional information can be incorporated through an external sample in which educational attainment is observed together with a related proxy, such as parental educational attainment. This external sample provides information on the underlying associations involving the target variable, which can be used to improve the statistical matching. The effectiveness of this extension depends on the selectivity of the external sample <span class="citation" data-cites="sojka2025">(<a href="#ref-sojka2025" role="doc-biblioref">Sojka 2025</a>)</span>.</p>
</section>
<section id="selectivity-in-the-external-sample" class="level3">
<h3 class="anchored" data-anchor-id="selectivity-in-the-external-sample">Selectivity in the External Sample</h3>
<p>Selectivity is a common feature of external data sources and characterizes the external sample <span class="citation" data-cites="bruggen2016">(<a href="#ref-bruggen2016" role="doc-biblioref">Brüggen, Brakel, and Krosnick 2016</a>)</span>. To describe these mechanisms, conditional selection probabilities are used. These probabilities denote the likelihood that unit i is included in the external sample, given the target variables, auxiliary variable and the unobserved factors that may influence this likelihood <span class="citation" data-cites="sojka2025">(<a href="#ref-sojka2025" role="doc-biblioref">Sojka 2025</a>)</span>. With respect to selection mechanisms, missing completely at random (MCAR), missing at random (MAR) and missing not at random (MNAR) are considered <span class="citation" data-cites="little2019 rubin1976">(<a href="#ref-little2019" role="doc-biblioref">Little and Rubin 2019</a>; <a href="#ref-rubin1976" role="doc-biblioref">Rubin 1976</a>)</span>. MCAR refers to the situation in which the selection probabilities are independent of the target variables, auxiliary variable or unobserved factors. MAR refers to the situation in which the selection probabilities only depend on the auxiliary variable. Finally, MNAR refers to the situation that the selection probabilities additionally depend on either the target variables, the unobserved factors, or both. Selectivity can further be characterized by the selectivity pattern and selectivity degree <span class="citation" data-cites="sojka2025">(<a href="#ref-sojka2025" role="doc-biblioref">Sojka 2025</a>)</span>. The selectivity pattern describes how the selection probabilities of unit i vary across the categories of X. The selectivity degree indicates how much the inclusion probabilities differ between the categories within a specific selectivity pattern. These probabilities are scaled such that the X category with the lowest selection probability is assigned the score 1. Selection scores for the remaining categories of X are then expressed relative to the baseline category using probability ratios. Moreover, the selectivity ratio is the probability ratio involving the baseline category, and the category of X with the highest selection score.</p>
</section>
<section id="doubly-robust-estimator" class="level3">
<h3 class="anchored" data-anchor-id="doubly-robust-estimator">Doubly Robust Estimator</h3>
<p>The joint distribution of Y and Z is primarily estimated by means of a so-called doubly robust estimator (DRE). Such an estimator generally involves two assumptions, whereby the estimate is unbiased in expectation when at least one of the assumptions holds <span class="citation" data-cites="bang2005">(<a href="#ref-bang2005" role="doc-biblioref">Bang and Robins 2005</a>)</span>. The first assumption is that the joint distribution can be correctly estimated based on the relation between the target variable Y and the proxy Y^* derived from the external sample. The second assumption is that the joint distribution can be correctly estimated from the unit overlap in samples A and B. These two estimates are combined with the model-implied estimate, P ̂(Y,Z)^CIA, is of the joint distribution assuming CIA validity, resulting in the doubly robust estimator shown in Equation (<span class="math inline">\(\ref{eq:dr}\)</span>). Intuitively, the doubly robust estimator corrects the overlap-based estimate using information form the external sample while adjusting for potential violations of the CIA.</p>
<p><span class="math display">\[\begin{equation}
\hat{P}(Y, X)^{\mathrm{DR}}
=
\hat{P}(Y, Z)^{\mathrm{AB}}
-
\hat{P}(Y, Z)^{\mathrm{CIA}}
+
\hat{P}(Y, Z)^{\mathrm{E}}
\label{eq:dr}
\end{equation}\]</span></p>
<p>If the external model P ̂(Y,Z)^E is correctly specified, the CIA estimate P ̂(Y,Z)^CIA coincides with the expected value of the overlap model P ̂(Y,Z)^AB. Consequently, these latter two terms in Equation 1 cancel each other out, reducing the DRE to the external estimate which is then theoretically unbiased. Moreover, if the overlap model is correctly specified, the DRE is unbiased because misspecifications in the external model estimate will also be reflected in the model-implied estimate such that the expectation of E[- P ̂(Y,Z)^CIA+P ̂(Y,Z)^E ]=0. Finally, the DRE is unbiased as well when the CIA is valid, since both the external as overlap models are then inherently correctly specified. However, if the CIA is violated in combination with misspecification of both models, the resulting estimates will be biased in expectation <span class="citation" data-cites="bang2005">(<a href="#ref-bang2005" role="doc-biblioref">Bang and Robins 2005</a>)</span>.</p>
</section>
<section id="performance-of-the-doubly-robust-estimator" class="level3">
<h3 class="anchored" data-anchor-id="performance-of-the-doubly-robust-estimator">Performance of the Doubly Robust Estimator</h3>
<p>In this section, data and design characteristics that are theoretically expected to affect the performance of the DRE are discussed. These characteristics include sample size, the degree of overlap between the samples, the quality of the proxy variable, the validity of the CIA, and the representativeness of the external sample. The performance is evaluated in terms of bias and variance of the estimated joint distribution of Y and Z. The sizes of samples A and B are expected to affect the performance of the DRE by reducing the sampling variability of the estimated distributions used in the CIA-based and overlap components. Consequently, larger sample sizes are associated with lower variance of the DRE estimate. The degree of unit overlap in samples A and B is anticipated to affect the performance by improving the accuracy of the overlap component, which reduces the bias of the DRE in expectation. The size of the external sample is expected to affect the DRE by reducing the sampling variability of the external model component. Again, larger external sample sizes are anticipated to reduce the variance of the DRE. However, selectivity in the external sample may introduce bias into the DRE in expectation. The quality of the proxy variable Y^* is expected to affect the performance of the DRE via its impact on the external model component. Proxy quality is characterized by the strength of the association between Y and Y^* and the structure of misclassification. Balanced misclassification implies evenly distributed misclassification across incorrect categories, whereas unbalanced misclassification implies uneven misclassification <span class="citation" data-cites="delden2016">(<a href="#ref-delden2016" role="doc-biblioref">Delden, Scholtus, and Burger 2016</a>)</span>. Balanced misclassification is anticipated to reduce bias in the external estimate in the DRE, as conditional distributions are less distorted and Y^* remains more representative of Y. Finally, the validity of the CIA is expected to affect the performance of the DRE, as violations of the CIA may introduce bias through the CIA-based component.</p>
</section>
<section id="benchmark-estimators" class="level3">
<h3 class="anchored" data-anchor-id="benchmark-estimators">Benchmark Estimators</h3>
<p>Iterative proportional fitting (IPF) is an alternative statistical matching procedure in which an initial joint distribution, referred to as a seed matrix, is iteratively adjusted to match known marginal distributions <span class="citation" data-cites="lovelace2015">(<a href="#ref-lovelace2015" role="doc-biblioref">Lovelace et al. 2015</a>)</span>. IPF has been shown to perform well under various simulation settings <span class="citation" data-cites="lovelace2015">(<a href="#ref-lovelace2015" role="doc-biblioref">Lovelace et al. 2015</a>)</span>. Therefore, IPF is suitable to serve as a benchmark estimator. In addition, an external-sample-based estimator (EXT) is considered. This estimator only relies on information from the external sample and does not use overlap information. The EXT provides a useful benchmark for assessing the added value of combining external and overlap information in the DRE.</p>
</section>
<section id="present-study" class="level3">
<h3 class="anchored" data-anchor-id="present-study">Present study</h3>
<p>Taken all together, this study evaluates how data and design characteristics affect the performance of statistical matching based on a proxy variable. Accordingly, the following research question is addressed: “To what extent do sample size, unit overlap, the validity of the conditional independence assumption, and the proxy quality affect the performance of statistical matching based on a proxy variable, and how does this compare to both iterative proportional fitting and external estimators?”. First, it is hypothesized that the DRE performs best when the sample sizes and unit overlap are larger. Second, the DRE is expected to exhibit lower bias when the association between the target variable and its proxy is strong, and its misclassification probabilities are balanced. Third, it is hypothesized that violations of the CIA increase bias for estimators that rely on this assumption, whereas the DRE is expected to be more robust under such violations than the benchmark estimators. Finally, it is hypothesized that the performance of the EXT is strongly associated with the representativeness of the external sample.</p>
</section>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<section id="data-generating-mechanisms" class="level3">
<h3 class="anchored" data-anchor-id="data-generating-mechanisms">Data Generating Mechanisms</h3>
<p>To evaluate the research question, a Monte Carlo simulation study is performed. For each set of simulation conditions, a synthetic population was generated, from which three samples were subsequently drawn. Table 1 provides an overview of the samples considered in this study and the categorical variables observed in each sample.</p>
<p>Table 1: Schematic representation of the three samples of interest, indicating the categorical variables that each sample contain with their corresponding number of levels. Sample Y (3) Z (3) X (6) Y* (3) A  <br>
B    E  </p>
<p>To model proxy quality, a transition matrix is used <span class="citation" data-cites="burger2015 delden2016">(<a href="#ref-burger2015" role="doc-biblioref">Burger, Delden, and Scholtus 2015</a>; <a href="#ref-delden2016" role="doc-biblioref">Delden, Scholtus, and Burger 2016</a>)</span>. The diagonal elements of the transition matrix represent the probability of correct classification p, while the off-diagonal elements w_ij represent misclassification probabilities, where i and j denote the categories of Y and Y^* respectively. For example, w_12 denotes the probability that an individual belonging to category Y_1 is misclassified into category Y_2^*. The classification probabilities were assumed to be independent of both X and Y. Furthermore, misclassification probabilities were constrained to sum to one conditional on Y. The generic structure of the transition matrix is shown in Table 2.</p>
<p>Table 2: Structure of the transition matrix structure used to generate the proxy variable. Y_1<sup>*&nbsp;Y_2</sup>* Y_3^* Y_1 p w_12 w_13 Y_2 w_21 p w_23 Y_3 w_31 w_32 p</p>
</section>
<section id="simulation-conditions" class="level3">
<h3 class="anchored" data-anchor-id="simulation-conditions">Simulation Conditions</h3>
<p>To systematically evaluate the performance of the estimators under varying data-generating settings, the study is organized into distinct simulations blocks and conditions. The simulation design distinguishes between different selection mechanisms in the external sample and varies data and design characteristics within each setting. With respect to the external sample, two separate simulation blocks were considered. In the first block, selection was assumed to be missing at random (MAR). Four selectivity patterns were implemented: linear decrease, U-shaped, step function, and extreme increase. For the linear decrease pattern, three selectivity degrees were considered, corresponding to reduced (3:1), original (6:1), reduced (3:1) and increased (12:1) selectivity ratios. In the second block, selection was assumed to be missing not at random (MNAR). Three main effects scenarios were considered, referred to as classic increase, non-monotonic and Y-only selection. For the classic increase scenario, four interaction effects scenarios were additionally implemented: weak, moderate, strong and extreme interaction. Within each simulation block, additional simulation conditions were varied. Table 3 provides an overview of these conditions and their corresponding levels.</p>
<p>Table 3: An overview of all conditions and their corresponding dimensions in the planned Monte Carlo study, regardless of the selection mechanism in the external sample. Condition Number of Dimensions Dimensions n 3 {1000,10000,100000}</p>
<p>n_E/n 3 {0.20,0.50,0.80 }</p>
<p>n_AB/n 3 {0,0.10,0.30}</p>
<p>p 3 {0.30,0.50,0.70}</p>
<p>w_ij=(1-p)/(K-1),i ≠j, 2 {True,False}</p>
<p>δ 3 {0,0.25,0.75}</p>
</section>
<section id="estimator-performance-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="estimator-performance-evaluation">Estimator Performance Evaluation</h3>
<p>The performance of the DRE was evaluated compared to the IPF and EXT estimators, serving as benchmarks. For each unique set of simulation conditions, all three estimators were computed. For the IPF estimator, the joint distribution of Y and Z was estimated using a seed matrix based on the overlapping units of samples A and B. If there was no unit overlap, the seed matrix was constructed as the outer product of the target marginal distributions of Y and Z obtained from samples A and B respectively. The IPF algorithm was run per level of X and then aggregated by weighting the resulting distributions using the marginal distribution of X. Estimator performance was evaluated in terms of bias and variance over T=1000 simulation runs. Bias was assessed by computing, for each cell k of the joint distribution, the deviation of the estimated cell value, θ ̂_k^((t)), from the true cell value, θ_k, in run t. The average absolute bias per cell was then calculated across the runs and subsequently averaged across all cells of the joint distribution Variance across the simulation runs was estimated using Welford’s algorithm (Welford, 1962). This approach updates the running mean and sum of squared deviations for each cell and yields a variance estimate. To jointly assess bias and variance, the mean squared error (MSE) was computed as the sum of squared bias and variance (Biemer, 2010). The MSE values were averaged across cells of the joint distribution, after which the square root was taken to obtain the root mean squared error (RMSE). Finally, estimator performance was compared using relative performance measures. The relative performance ∆_C compares the average the error measure (i.e.&nbsp;bias, variance or RMSE) of the DRE to that of a comparative estimator C (i.e.&nbsp;IPF or EXT). A negative ∆_C value indicates that the DRE performs better relative to the comparative estimator and vice versa.</p>
</section>
</section>
<section id="hypothethical-results" class="level2">
<h2 class="anchored" data-anchor-id="hypothethical-results">Hypothethical Results</h2>
<p>Figure 1 displays the RMSE values under MNAR selection mechanisms as a function of proxy association strength, unit overlap, estimator and MNAR scenario. Across all MNAR scenarios, the DRE consistently yields the lowest RMSE values, indicating superior performance relative to both the IPF and EXT estimators. The IPF estimator shows better performance than the EXT estimator. For all estimators, stronger proxy associations are associated with lower RMSE values indicating improved accuracy. In addition, increasing unit overlap size also leads to lower RMSE values. Finally, differences across MNAR scenarios indicate that more severe forms of CIA violation result in increased estimation error, especially for the EXT estimator. The DRE remains comparatively stable across scenarios.</p>
</section>
<section id="references" class="level2 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bang2005" class="csl-entry" role="listitem">
Bang, Heejung, and James M. Robins. 2005. <span>“Doubly Robust Estimation in Missing Data and Causal Inference Models.”</span> <em>Biometrics</em> 61 (4): 962–73. <a href="https://doi.org/10.1111/j.1541-0420.2005.00377.x">https://doi.org/10.1111/j.1541-0420.2005.00377.x</a>.
</div>
<div id="ref-biemer2010" class="csl-entry" role="listitem">
Biemer, Paul P. 2010. <span>“Total <span>Survey</span> <span>Error</span>: <span>Design</span>, <span>Implementation</span>, and <span>Evaluation</span>.”</span> <em>Public Opinion Quarterly</em> 74 (5): 817–48. <a href="https://doi.org/10.1093/poq/nfq058">https://doi.org/10.1093/poq/nfq058</a>.
</div>
<div id="ref-bruggen2016" class="csl-entry" role="listitem">
Brüggen, E., J. van den Brakel, and J. Krosnick. 2016. <span>“Establishing the Accuracy of Online Panels for Survey Research.”</span> Webpagina. <em>Statistics Netherlands</em>. <a href="https://www.cbs.nl/en-gb/background/2016/15/establishing-the-accuracy-of-online-panels-for-survey-research">https://www.cbs.nl/en-gb/background/2016/15/establishing-the-accuracy-of-online-panels-for-survey-research</a>.
</div>
<div id="ref-burger2015" class="csl-entry" role="listitem">
Burger, Joep, Arnout Delden, and Sander Scholtus. 2015. <span>“Sensitivity of <span>Mixed</span>-<span>Source</span> <span>Statistics</span> to <span>Classification</span> <span>Errors</span>.”</span> <em>Journal of Official Statistics</em> 31 (September): 489–506. <a href="https://doi.org/10.1515/JOS-2015-0029">https://doi.org/10.1515/JOS-2015-0029</a>.
</div>
<div id="ref-dorazio2006" class="csl-entry" role="listitem">
D’Orazio, Marcello, Marco Di Zio, and Mauro Scanu. 2006. <em>Statistical <span>Matching</span>: <span>Theory</span> and <span>Practice</span></em>. John Wiley &amp; Sons.
</div>
<div id="ref-delden2016" class="csl-entry" role="listitem">
Delden, Arnout van, Sander Scholtus, and Joep Burger. 2016. <span>“Accuracy of <span>Mixed</span>-<span>Source</span> <span>Statistics</span> as <span>Affected</span> by <span>Classification</span> <span>Errors</span>.”</span> <em>Journal of Official Statistics</em> 32 (3): 619–42. <a href="https://doi.org/10.1515/jos-2016-0032">https://doi.org/10.1515/jos-2016-0032</a>.
</div>
<div id="ref-donatiello2022" class="csl-entry" role="listitem">
Donatiello, Gabriella, Doriana Frattarola, Mattia Spaziani, and Marcello D’Orazio. 2022. <span>“The Joint Distribution of Income and Consumption in <span>Italy</span>: An in-Depth Analysis on Statistical Matching,”</span> December. <a href="https://doi.org/10.1481/ISTATRIVISTASTATISTICAUFFICIALE_3.2022.03">https://doi.org/10.1481/ISTATRIVISTASTATISTICAUFFICIALE_3.2022.03</a>.
</div>
<div id="ref-groves2010" class="csl-entry" role="listitem">
Groves, Robert M., and Lars Lyberg. 2010. <span>“Total <span>Survey</span> <span>Error</span>: <span>Past</span>, <span>Present</span>, and <span>Future</span>.”</span> <em>Public Opinion Quarterly</em> 74 (5): 849–79. <a href="https://doi.org/10.1093/poq/nfq065">https://doi.org/10.1093/poq/nfq065</a>.
</div>
<div id="ref-little2019" class="csl-entry" role="listitem">
Little, Roderick, and Donald Rubin. 2019. <em>Statistical <span>Analysis</span> with <span>Missing</span> <span>Data</span>, <span>Third</span> <span>Edition</span></em>. 1st ed. Wiley <span>Series</span> in <span>Probability</span> and <span>Statistics</span>. Wiley. <a href="https://doi.org/10.1002/9781119482260">https://doi.org/10.1002/9781119482260</a>.
</div>
<div id="ref-lovelace2015" class="csl-entry" role="listitem">
Lovelace, Robin, Mark Birkin, Dimitris Ballas, and Eveline van Leeuwen. 2015. <span>“Evaluating the <span>Performance</span> of <span>Iterative</span> <span>Proportional</span> <span>Fitting</span> for <span>Spatial</span> <span>Microsimulation</span>: <span>New</span> <span>Tests</span> for an <span>Established</span> <span>Technique</span>.”</span> <em>Journal of Artificial Societies and Social Simulation</em> 18 (2): 21.
</div>
<div id="ref-luiten2020" class="csl-entry" role="listitem">
Luiten, A, J. J. C. M. Hox, and E. D. de Leeuw. 2020. <span>“Survey <span>Nonresponse</span> <span>Trends</span> and <span>Fieldwork</span> <span>Effort</span> in the 21st <span>Century</span>: <span>Results</span> of an <span>International</span> <span>Study</span> Across <span>Countries</span> and <span>Surveys</span>.”</span> <em>Journal of Official Statistics</em> 36 (3): 469–87. <a href="https://doi.org/10.2478/jos-2020-0025">https://doi.org/10.2478/jos-2020-0025</a>.
</div>
<div id="ref-rubin1976" class="csl-entry" role="listitem">
Rubin, Donald, B. 1976. <span>“Inference and Missing Data.”</span> <em>Biometrika</em> 63 (3): 581–92. <a href="https://doi.org/10.1093/biomet/63.3.581">https://doi.org/10.1093/biomet/63.3.581</a>.
</div>
<div id="ref-sojka2025" class="csl-entry" role="listitem">
Sojka, B. L. 2025. <span>“Statistical <span>Matching</span> Using a <span>Non</span>-<span>Probability</span> <span>Sample</span> as <span>Auxiliary</span> <span>Dataset</span>.”</span>
</div>
<div id="ref-waal2015" class="csl-entry" role="listitem">
Waal, A. G. de. 2015. <em>Statistical Matching: <span>Experimental</span> Results and Future Research Questions</em>. Den Haag: CBS.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>